
export interface NormalizedColumn {
    type: string;
    nullable?: boolean;
    primary?: boolean;
    unique?: boolean;
    default?: string;
    foreign_key?: string; // Format: "table.column"
}

export interface NormalizedIndex {
    name: string;
    columns: string[];
    unique: boolean;
}

export interface NormalizedRelation {
    type: 'one_to_one' | 'one_to_many' | 'many_to_one' | 'many_to_many';
    from: string; // Format: "table.column"
    to: string;   // Format: "table.column"
}

export interface NormalizedTable {
    columns: Record<string, NormalizedColumn>;
    relations: NormalizedRelation[];
    indexes: NormalizedIndex[];
}

export interface NormalizedSchema {
    tables: Record<string, NormalizedTable>;
}

export interface ParsingResult {
    status: 'success' | 'partial' | 'error';
    input_type: 'sql' | 'prisma' | 'unknown';
    errors: string[];
    warnings: string[];
    schema: NormalizedSchema;
    stats: {
        table_count: number;
        column_count: number;
        relation_count: number;
    };
}

function cleanSql(sql: string): string {
    return sql
        .replace(/--.*$/gm, '')
        .replace(/\/\*[\s\S]*?\*\//g, '')
        .replace(/\s+/g, ' ')
        .trim();
}

function splitByComma(str: string): string[] {
    const parts: string[] = [];
    let current = '';
    let parenDepth = 0;

    for (let i = 0; i < str.length; i++) {
        const char = str[i];
        if (char === '(') parenDepth++;
        if (char === ')') parenDepth--;

        if (char === ',' && parenDepth === 0) {
            parts.push(current);
            current = '';
        } else {
            current += char;
        }
    }
    if (current) parts.push(current);
    return parts;
}

export function parseSqlDeterministc(rawSchema: string): ParsingResult {
    const result: ParsingResult = {
        status: 'success',
        input_type: 'sql',
        errors: [],
        warnings: [],
        schema: { tables: {} },
        stats: { table_count: 0, column_count: 0, relation_count: 0 }
    };

    try {
        const cleaned = cleanSql(rawSchema);
        const statements = cleaned.split(';').map(s => s.trim()).filter(s => s.length > 0);

        const pendingRelations: Array<{
            fromTable: string;
            fromCol: string;
            toTable: string;
            toCol: string;
            type: NormalizedRelation['type'];
        }> = [];

        for (const stmt of statements) {
            const createTableMatch = stmt.match(/create\s+table\s+(?:if\s+not\s+exists\s+)?["`]?(\w+)["`]?\s*\(([\s\S]*)\)/i);

            if (createTableMatch && createTableMatch[1] && createTableMatch[2]) {
                const tableName = createTableMatch[1];
                const body = createTableMatch[2];

                result.schema.tables[tableName] = {
                    columns: {},
                    indexes: [],
                    relations: []
                };

                const parts = splitByComma(body);

                for (const part of parts) {
                    const def = part.trim();
                    if (!def) continue;
                    const upperDef = def.toUpperCase();

                    // 1. Detect Explicit FOREIGN KEY Constraint
                    // Matches: [CONSTRAINT name] FOREIGN KEY (cols) REFERENCES table(cols)
                    if (upperDef.includes('FOREIGN KEY')) {
                        const fkMatch = def.match(/(?:CONSTRAINT\s+\w+\s+)?FOREIGN\s+KEY\s*\(([\w",\s]+)\)\s*REFERENCES\s+["`]?(\w+)["`]?\s*\(([\w",\s]+)\)/i);
                        if (fkMatch) {
                            const [, colsRaw, refTable, refColsRaw] = fkMatch;

                            if (colsRaw && refTable && refColsRaw) {
                                // Handle composite keys or single keys - clean quotes/spaces
                                const fCols = colsRaw.split(',').map(c => c.trim().replace(/["`]/g, ''));
                                const tCols = refColsRaw.split(',').map(c => c.trim().replace(/["`]/g, ''));

                                // but we should process the first one at minimum.
                                if (fCols.length > 0 && tCols.length > 0) {
                                    const fCol = fCols[0];
                                    const tCol = tCols[0];

                                    if (fCol && tCol) {
                                        pendingRelations.push({
                                            fromTable: tableName,
                                            fromCol: fCol,
                                            toTable: refTable!,
                                            toCol: tCol,
                                            type: 'many_to_one'
                                        });
                                    }
                                }
                            }
                            continue; // Done with this part
                        }
                    }

                    // 2. Detect PRIMARY KEY Constraint
                    if (upperDef.includes('PRIMARY KEY') && (upperDef.startsWith('CONSTRAINT') || upperDef.startsWith('PRIMARY'))) {
                        const pkMatch = def.match(/PRIMARY\s+KEY\s*\(([\w",\s]+)\)/i);
                        if (pkMatch && pkMatch[1]) {
                            const pkCols = pkMatch[1].split(',').map(c => c.trim().replace(/["`]/g, ''));
                            pkCols.forEach(pkCol => {
                                const table = result.schema.tables[tableName];
                                if (table && table.columns[pkCol]) {
                                    table.columns[pkCol].primary = true;
                                }
                            });
                        }
                        continue;
                    }

                    // 3. Regular Column Definition (potentially with inline PRIMARY KEY or REFERENCES)
                    // Matches: name type constraints...
                    const colMatch = def.match(/^["`]?(\w+)["`]?\s+([^\s]+)(.*)/);
                    if (colMatch && colMatch[1] && colMatch[2]) {
                        const colName = colMatch[1];
                        const colType = colMatch[2];
                        const rest = colMatch[3] || '';

                        // Inline Constraints
                        const isPk = rest.toUpperCase().includes('PRIMARY KEY');
                        const isUnique = rest.toUpperCase().includes('UNIQUE');
                        const notNull = rest.toUpperCase().includes('NOT NULL');

                        // Inline Foreign Key: ... REFERENCES users(id)
                        const inlineRefMatch = rest.match(/REFERENCES\s+["`]?(\w+)["`]?\s*\(([\w",\s]+)\)/i);
                        let fkDef: string | undefined = undefined;

                        if (inlineRefMatch && inlineRefMatch[1] && inlineRefMatch[2]) {
                            const iToTable = inlineRefMatch[1];
                            const iToCol = inlineRefMatch[2].replace(/["`]/g, ''); // Clean quotes

                            fkDef = `${iToTable}.${iToCol}`;

                            pendingRelations.push({
                                fromTable: tableName,
                                fromCol: colName,
                                toTable: iToTable,
                                toCol: iToCol,
                                type: 'many_to_one'
                            });
                        }

                        const colDef: NormalizedColumn = {
                            type: colType,
                            nullable: !notNull,
                            primary: isPk,
                            unique: isUnique
                        };
                        if (fkDef) colDef.foreign_key = fkDef;

                        const table = result.schema.tables[tableName];
                        if (table) table.columns[colName] = colDef;
                    }
                }
            } else if (stmt.match(/^ALTER\s+TABLE/i)) {
                // ALTER TABLE ADD CONSTRAINT FOREIGN KEY
                const alterMatch = stmt.match(/ALTER\s+TABLE\s+["`]?(\w+)["`]?\s+ADD\s+(?:CONSTRAINT\s+\w+\s+)?FOREIGN\s+KEY\s*\(([\w",\s]+)\)\s*REFERENCES\s+["`]?(\w+)["`]?\s*\(([\w",\s]+)\)/i);
                if (alterMatch && alterMatch[1] && alterMatch[2] && alterMatch[3] && alterMatch[4]) {
                    const fTable = alterMatch[1];
                    const fCol = alterMatch[2].trim().replace(/["`]/g, '');
                    const tTable = alterMatch[3];
                    const tCol = alterMatch[4].trim().replace(/["`]/g, '');

                    pendingRelations.push({
                        fromTable: fTable,
                        fromCol: fCol,
                        toTable: tTable,
                        toCol: tCol,
                        type: 'many_to_one'
                    });
                }
            }
        }

        for (const rel of pendingRelations) {
            const fTable = result.schema.tables[rel.fromTable];
            const tTable = result.schema.tables[rel.toTable];

            if (fTable) {
                fTable.relations.push({
                    type: rel.type,
                    from: `${rel.fromTable}.${rel.fromCol}`,
                    to: `${rel.toTable}.${rel.toCol}`
                });
                const fCol = fTable.columns[rel.fromCol];
                if (fCol) {
                    fCol.foreign_key = `${rel.toTable}.${rel.toCol}`;
                }
            }
            if (tTable) {
                tTable.relations.push({
                    type: 'one_to_many',
                    from: `${rel.toTable}.${rel.toCol}`,
                    to: `${rel.fromTable}.${rel.fromCol}`
                });
            }
        }

        result.stats.table_count = Object.keys(result.schema.tables).length;
        result.stats.relation_count = pendingRelations.length;
        result.stats.column_count = Object.values(result.schema.tables).reduce((acc, t) => acc + Object.keys(t.columns).length, 0);

        if (result.stats.table_count === 0) {
            result.status = 'error';
            result.errors.push("No tables found in input.");
        } else if (result.stats.relation_count === 0) {
            // This is NOT an error - just a helpful warning
            result.warnings.push("No foreign key relationships detected. ER diagrams will show tables only.");
        }

    } catch (e: any) {
        result.status = 'error';
        result.errors.push("Parsing Exception: " + e.message);
    }

    return result;
}

// --- GENERATORS ---

export function generateSql(schema: NormalizedSchema): string {
    let sql = '';

    for (const [tableName, table] of Object.entries(schema.tables)) {
        sql += `CREATE TABLE ${tableName} (\n`;
        const colLines = Object.entries(table.columns).map(([name, col]) => {
            let line = `  ${name} ${col.type}`;
            if (col.primary) line += ' PRIMARY KEY';
            if (!col.nullable) line += ' NOT NULL';
            if (col.unique && !col.primary) line += ' UNIQUE';
            if (col.default) line += ` DEFAULT ${col.default}`;
            return line;
        });

        sql += colLines.join(',\n');
        sql += '\n);\n\n';
    }

    for (const [tableName, table] of Object.entries(schema.tables)) {
        for (const rel of table.relations) {
            if (rel.type === 'many_to_one') {
                const partsFrom = rel.from.split('.');
                const partsTo = rel.to.split('.');
                const fromCol = partsFrom[1];
                const toTable = partsTo[0];
                const toCol = partsTo[1];

                if (fromCol && toTable && toCol) {
                    sql += `ALTER TABLE ${tableName} ADD CONSTRAINT fk_${tableName}_${fromCol} FOREIGN KEY (${fromCol}) REFERENCES ${toTable}(${toCol});\n`;
                }
            }
        }
    }

    return sql;
}

export function generatePrisma(schema: NormalizedSchema): string {
    let prisma = 'datasource db {\n  provider = "postgresql"\n  url      = env("DATABASE_URL")\n}\n\ngenerator client {\n  provider = "prisma-client-js"\n}\n\n';

    for (const [tableName, table] of Object.entries(schema.tables)) {
        const modelName = tableName.charAt(0).toUpperCase() + tableName.slice(1);
        prisma += `model ${modelName} {\n`;

        for (const [colName, col] of Object.entries(table.columns)) {
            let type = col.type.toLowerCase();
            if (type === 'uuid') type = 'String @db.Uuid';
            else if (type === 'int' || type === 'integer' || type === 'serial') type = 'Int';
            else if (type === 'text' || type === 'varchar') type = 'String';
            else if (type === 'timestamp' || type === 'timestamptz') type = 'DateTime';
            else if (type === 'boolean') type = 'Boolean';
            else type = 'String';

            let line = `  ${colName} ${type}`;
            if (col.primary) line += ' @id';
            if (col.unique && !col.primary) line += ' @unique';
            if (col.default) {
                if (col.default.toLowerCase().includes('now()')) line += ' @default(now())';
                else if (col.default.toLowerCase().includes('uuid_generate_v4()')) line += ' @default(uuid())';
            }
            prisma += line + '\n';
        }

        for (const rel of table.relations) {
            if (rel.type === 'many_to_one') {
                const partsTo = rel.to.split('.');
                const partsFrom = rel.from.split('.');

                const targetTable = partsTo[0];
                const targetCol = partsTo[1];
                const sourceCol = partsFrom[1];

                if (targetTable && targetCol && sourceCol) {
                    const targetModel = targetTable.charAt(0).toUpperCase() + targetTable.slice(1);
                    prisma += `  ${targetTable} ${targetModel} @relation(fields: [${sourceCol}], references: [${targetCol}])\n`;
                }
            } else if (rel.type === 'one_to_many') {
                const targetTable = rel.to.split('.')[0];
                if (targetTable) {
                    const targetModel = targetTable.charAt(0).toUpperCase() + targetTable.slice(1);
                    prisma += `  ${targetTable} ${targetModel}[]\n`;
                }
            }
        }

        prisma += '}\n\n';
    }

    return prisma;
}

export function generateDrizzle(schema: NormalizedSchema): string {
    let drizzle = `import { pgTable, uuid, text, timestamp, boolean, integer } from "drizzle-orm/pg-core";\n\n`;

    for (const [tableName, table] of Object.entries(schema.tables)) {
        drizzle += `export const ${tableName} = pgTable("${tableName}", {\n`;

        for (const [colName, col] of Object.entries(table.columns)) {
            let builder = '';
            const type = col.type.toLowerCase();
            if (type === 'uuid') builder = `uuid("${colName}")`;
            else if (type === 'int' || type === 'integer' || type === 'serial') builder = `integer("${colName}")`;
            else if (type === 'text' || type === 'varchar') builder = `text("${colName}")`;
            else if (type === 'timestamp' || type === 'timestamptz') builder = `timestamp("${colName}")`;
            else if (type === 'boolean') builder = `boolean("${colName}")`;
            else builder = `text("${colName}")`;

            if (col.primary) builder += '.primaryKey()';
            if (!col.nullable) builder += '.notNull()';
            if (col.unique && !col.primary) builder += '.unique()';
            if (col.default) {
                if (col.default.toLowerCase().includes('now()')) builder += '.defaultNow()';
            }

            drizzle += `  ${colName}: ${builder},\n`;
        }

        drizzle += '});\n\n';
    }

    return drizzle;
}

export interface ChangeObject {
    change_type: 'table_added' | 'table_removed' | 'column_added' | 'column_removed' | 'column_modified' | 'relation_added' | 'relation_removed' | 'relation_modified';
    entity_name: string;
    details: any;
}

export function compareSchemas(oldSchema: NormalizedSchema, newSchema: NormalizedSchema): ChangeObject[] {
    const changes: ChangeObject[] = [];

    const oldTables = Object.keys(oldSchema.tables);
    const newTables = Object.keys(newSchema.tables);

    // 1. Table additions/removals
    newTables.filter(t => !oldTables.includes(t)).forEach(t => {
        changes.push({ change_type: 'table_added', entity_name: t, details: { table: t } });
    });
    oldTables.filter(t => !newTables.includes(t)).forEach(t => {
        changes.push({ change_type: 'table_removed', entity_name: t, details: { table: t } });
    });

    // 2. Column additions/removals/modifications
    for (const table of newTables.filter(t => oldTables.includes(t))) {
        const oldTable = oldSchema.tables[table];
        const newTable = newSchema.tables[table];
        if (!oldTable || !newTable) continue;

        const oldCols = Object.keys(oldTable.columns);
        const newCols = Object.keys(newTable.columns);

        newCols.filter(c => !oldCols.includes(c)).forEach(c => {
            const col = newTable.columns[c];
            if (col) {
                changes.push({ change_type: 'column_added', entity_name: `${table}.${c}`, details: { table, column: c, type: col.type } });
            }
        });
        oldCols.filter(c => !newCols.includes(c)).forEach(c => {
            changes.push({ change_type: 'column_removed', entity_name: `${table}.${c}`, details: { table, column: c } });
        });

        for (const col of newCols.filter(c => oldCols.includes(c))) {
            const oldC = oldTable.columns[col];
            const newC = newTable.columns[col];
            if (!oldC || !newC) continue;

            if (oldC.type !== newC.type) {
                changes.push({
                    change_type: 'column_modified',
                    entity_name: `${table}.${col}`,
                    details: { table, column: col, old_type: oldC.type, new_type: newC.type, diff: 'type' }
                });
            } else if (oldC.nullable !== newC.nullable) {
                changes.push({
                    change_type: 'column_modified',
                    entity_name: `${table}.${col}`,
                    details: { table, column: col, old_nullable: oldC.nullable, new_nullable: newC.nullable, diff: 'nullability' }
                });
            }
        }

        // 3. Relation changes
        const oldRels = oldTable.relations.map(r => `${r.from}->${r.to}`);
        const newRels = newTable.relations.map(r => `${r.from}->${r.to}`);

        newTable.relations.filter(r => !oldRels.includes(`${r.from}->${r.to}`)).forEach(r => {
            changes.push({ change_type: 'relation_added', entity_name: `${r.from}->${r.to}`, details: r });
        });
        oldTable.relations.filter(r => !newRels.includes(`${r.from}->${r.to}`)).forEach(r => {
            changes.push({ change_type: 'relation_removed', entity_name: `${r.from}->${r.to}`, details: r });
        });
    }

    return changes;
}

export function parsePrisma(prisma: string): ParsingResult {
    const result: ParsingResult = {
        status: 'success',
        input_type: 'prisma',
        errors: [],
        warnings: [],
        schema: { tables: {} },
        stats: { table_count: 0, column_count: 0, relation_count: 0 }
    };

    try {
        const models = prisma.match(/model\s+(\w+)\s*{([\s\S]*?)}/g);
        if (!models) {
            result.status = 'error';
            result.errors.push("No models found in Prisma schema.");
            return result;
        }

        for (const model of models) {
            const nameMatch = model.match(/model\s+(\w+)/);
            if (!nameMatch || !nameMatch[1]) continue;
            const tableName = nameMatch[1].toLowerCase();
            const bodyMatch = model.match(/{([\s\S]*?)}/);
            const body = (bodyMatch && bodyMatch[1]) ? bodyMatch[1] : '';

            result.schema.tables[tableName] = {
                columns: {},
                indexes: [],
                relations: []
            };

            const lines = body.split('\n').map(l => l.trim()).filter(l => l.length > 0);
            for (const line of lines) {
                if (line.startsWith('@@')) continue;

                const parts = line.split(/\s+/);
                if (parts.length < 2) continue;

                const colName = parts[0];
                const colTypeRaw = parts[1] || '';
                const rest = parts.slice(2).join(' ') || '';

                const isPk = rest.includes('@id');
                const isUnique = rest.includes('@unique');
                const isOptional = colTypeRaw.endsWith('?');

                let type = colTypeRaw.replace('?', '');
                if (type === 'String') type = 'text';
                else if (type === 'Int') type = 'integer';
                else if (type === 'DateTime') type = 'timestamp';
                else if (type === 'Boolean') type = 'boolean';
                else if (type === 'Json') type = 'jsonb';

                if (colName) {
                    const table = result.schema.tables[tableName];
                    if (table) {
                        table.columns[colName] = {
                            type,
                            nullable: isOptional,
                            primary: isPk,
                            unique: isUnique
                        };
                    }
                }
            }
        }

        result.stats.table_count = Object.keys(result.schema.tables).length;
        result.stats.column_count = Object.values(result.schema.tables).reduce((acc, t) => acc + Object.keys(t.columns).length, 0);

    } catch (e: any) {
        result.status = 'error';
        result.errors.push(e.message);
    }

    return result;
}

export function parseDrizzle(drizzle: string): ParsingResult {
    const result: ParsingResult = {
        status: 'success',
        input_type: 'prisma', // Using 'prisma' as generic ORM type
        errors: [],
        warnings: [],
        schema: { tables: {} },
        stats: { table_count: 0, column_count: 0, relation_count: 0 }
    };

    try {
        // Match: export const tableName = pgTable("tableName", { ... });
        const tableMatches = drizzle.matchAll(/export\s+const\s+(\w+)\s*=\s*pgTable\s*\(\s*["'](\w+)["']\s*,\s*\{([\s\S]*?)\}\s*\)/g);

        let foundTables = false;
        for (const match of tableMatches) {
            foundTables = true;
            const varName = match[1];
            const tableName = match[2];
            const body = match[3];

            if (!tableName || !body) continue;

            result.schema.tables[tableName] = {
                columns: {},
                indexes: [],
                relations: []
            };

            // Parse column definitions
            // Format: columnName: type("columnName").modifiers(),
            const columnPattern = /(\w+)\s*:\s*(\w+)\s*\([^)]*\)([^,]*)/g;
            let colMatch;

            while ((colMatch = columnPattern.exec(body)) !== null) {
                const colName = colMatch[1];
                const colType = colMatch[2];
                const modifiers = colMatch[3] || '';

                // Map Drizzle types to SQL types
                let sqlType = 'text';
                if (colType === 'uuid') sqlType = 'uuid';
                else if (colType === 'integer' || colType === 'int') sqlType = 'integer';
                else if (colType === 'text' || colType === 'varchar') sqlType = 'text';
                else if (colType === 'timestamp') sqlType = 'timestamp';
                else if (colType === 'boolean') sqlType = 'boolean';
                else if (colType === 'serial') sqlType = 'serial';

                const isPk = modifiers.includes('.primaryKey()');
                const isUnique = modifiers.includes('.unique()');
                const notNull = modifiers.includes('.notNull()');

                if (colName && tableName) {
                    result.schema.tables[tableName].columns[colName] = {
                        type: sqlType,
                        nullable: !notNull && !isPk,
                        primary: isPk,
                        unique: isUnique
                    };
                }
            }

            foundTables = true;
        }

        if (!foundTables) {
            result.status = 'error';
            result.errors.push("No pgTable definitions found in Drizzle schema.");
            return result;
        }

        result.stats.table_count = Object.keys(result.schema.tables).length;
        result.stats.column_count = Object.values(result.schema.tables).reduce((acc, t) => acc + Object.keys(t.columns).length, 0);

        if (result.stats.table_count === 0) {
            result.status = 'error';
            result.errors.push("No tables found in Drizzle schema.");
        }

    } catch (e: any) {
        result.status = 'error';
        result.errors.push(e.message);
    }

    return result;
}

