import { marked } from 'marked';
import puppeteer from 'puppeteer';
import { supabase } from '../lib/supabase.js';
import { NormalizedSchema } from '../../parser.js';
import { getWorkspaceIdFromProject } from '../utils/dbHelpers.js';
import { checkFeatureAccess } from '../../billing.js';

export async function generateDocumentation(projectId: string, versionNumber: number) {
    console.log(`[AutoDocs] Generating documentation for project ${projectId} v${versionNumber}`);

    try {
        // 1. Load Data
        const { data: version } = await supabase.from('schema_versions')
            .select('*')
            .eq('project_id', projectId)
            .eq('version', versionNumber)
            .single();

        if (!version) throw new Error("Schema version not found");

        const { data: explanations, error: eErr } = await supabase.from('schema_explanations')
            .select('*')
            .eq('project_id', projectId)
            .eq('version_number', versionNumber);

        if (eErr) console.warn('[AutoDocs] Explanations fetch warning:', eErr.message);

        const { data: changes, error: cErr } = await supabase.from('schema_changes')
            .select('*')
            .eq('project_id', projectId)
            .eq('to_version', versionNumber);

        if (cErr) console.warn('[AutoDocs] Change tracking fetch warning (Is the table created?):', cErr.message);

        // 2. Build Markdown
        const schema = version.normalized_schema as NormalizedSchema;
        const dbExp = explanations?.find((e: any) => e.entity_type === 'database')?.content || "This database consists of multiple tables designed to support application data storage and relationships.";
        const relExp = explanations?.find((e: any) => e.entity_type === 'relationship')?.content || "Standard primary and foreign key constraints are implemented to ensure data integrity.";

        let md = `# Database Documentation\n\n`;
        md += `## Overview\n${dbExp}\n\n`;

        const tableCount = Object.keys(schema.tables).length;
        const colCount = Object.values(schema.tables).reduce((acc, t) => acc + Object.keys(t.columns).length, 0);
        const relCount = Object.values(schema.tables).reduce((acc, t: any) => acc + (t.relations?.length || 0), 0);

        md += `## Schema Summary\n`;
        md += `- **Total Tables:** ${tableCount}\n`;
        md += `- **Total Columns:** ${colCount}\n`;
        md += `- **Total Relationships:** ${relCount}\n\n`;

        md += `## Entities\n\n`;
        for (const [tableName, table] of Object.entries(schema.tables)) {
            const tableExp = explanations?.find((e: any) => e.entity_type === 'table' && e.entity_name === tableName)?.content || `The ${tableName} table persists structured records and supports the core business logic of the application.`;

            md += `### ${tableName}\n${tableExp}\n\n`;
            md += `#### Columns\n`;
            md += `| Column | Type | Constraints | Description |\n`;
            md += `|------|------|------------|-------------|\n`;

            for (const [colName, col] of Object.entries(table.columns)) {
                const constraints = [];
                if (col.primary) constraints.push('PK');
                if (col.foreign_key) constraints.push(`FK (${col.foreign_key})`);
                if (!col.nullable) constraints.push('NOT NULL');
                if (col.unique) constraints.push('UNIQUE');

                md += `| ${colName} | ${col.type} | ${constraints.join(', ')} | ${col.primary ? 'Unique identifier' : 'Attribute'} |\n`;
            }
            md += `\n`;

            if (table.relations && table.relations.length > 0) {
                md += `#### Key Relationships\n`;
                table.relations.forEach((rel: any) => {
                    md += `- **${rel.from}** â†’ **${rel.to}** (${rel.type})\n`;
                });
                md += `\n`;
            }
            md += `---\n\n`;
        }

        md += `## Relationships Detail\n${relExp}\n\n`;

        if (changes && changes.length > 0) {
            md += `## Version Change History\n`;
            changes.forEach((c: any) => {
                const type = c.change_type.toUpperCase().replace(/_/g, ' ');
                md += `- **[${type}]**: ${c.entity_name}\n`;
            });
            md += `\n`;
        }

        md += `## Notes\n*Documentation automatically generated by Vizora AI engine on ${new Date().toLocaleDateString()}*.\n`;

        // 3. Save to DB (Cleanup old first to simulate upsert on project_id/version if no constraint)
        await supabase.from('documentation_outputs')
            .delete()
            .eq('project_id', projectId)
            .eq('version', versionNumber);

        const { error: insErr } = await supabase.from('documentation_outputs').insert({
            project_id: projectId,
            version: versionNumber,
            markdown: md
        });

        if (insErr) throw insErr;
        console.log(`[AutoDocs] Markdown version created for v${versionNumber}`);

        // 4. Trigger PDF Generation (Async) - BILLING CHECK
        const workspaceId = await getWorkspaceIdFromProject(projectId);
        if (workspaceId) {
            const canExport = await checkFeatureAccess(workspaceId, 'exports');
            if (canExport) {
                generatePdf(projectId, versionNumber, md).catch(err => {
                    console.error('[AutoDocs] PDF Generation failed:', err);
                });
            } else {
                console.log(`[AutoDocs] Exports disabled for workspace ${workspaceId}. PDF generation skipped.`);
            }
        }

    } catch (err: any) {
        console.error('[AutoDocs] Error:', err.message);
    }
}

async function generatePdf(projectId: string, versionNumber: number, markdown: string) {
    console.log(`[AutoDocs] Rendering PDF artifact for project ${projectId} v${versionNumber}`);

    try {
        const htmlContent = `
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body { font-family: 'Inter', system-ui, sans-serif; line-height: 1.6; color: #1e293b; max-width: 850px; margin: 0 auto; padding: 50px; }
                    h1 { color: #0f172a; border-bottom: 3px solid #4f46e5; padding-bottom: 15px; font-size: 32px; font-weight: 800; }
                    h2 { color: #4338ca; margin-top: 40px; border-bottom: 1px solid #e2e8f0; padding-bottom: 8px; font-size: 24px; font-weight: 700; }
                    h3 { color: #1e1b4b; margin-top: 30px; background: #f8fafc; padding: 12px 20px; border-radius: 8px; font-size: 18px; font-weight: 800; border-left: 4px solid #4f46e5; }
                    table { width: 100%; border-collapse: collapse; margin: 25px 0; font-size: 14px; }
                    th, td { border: 1px solid #e2e8f0; padding: 14px; text-align: left; }
                    th { background-color: #f1f5f9; color: #475569; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; }
                    tr:nth-child(even) { background-color: #f8fafc; }
                    .footer { margin-top: 80px; text-align: center; color: #94a3b8; font-size: 11px; border-top: 1px solid #f1f5f9; padding-top: 20px; }
                    @media print {
                        h3 { page-break-after: avoid; }
                        table { page-break-inside: auto; }
                        tr { page-break-inside: avoid; page-break-after: auto; }
                        .no-break { page-break-inside: avoid; }
                    }
                </style>
            </head>
            <body>
                ${marked.parse(markdown)}
                <div class="footer">
                    &copy; ${new Date().getFullYear()} Vizora Schema Intelligence Engine. All architectural insights are generated deterministically from schema source.
                </div>
            </body>
            </html>
        `;

        const browser = await puppeteer.launch({
            headless: true,
            args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        const page = await browser.newPage();
        await page.setContent(htmlContent);

        const pdfBuffer = await page.pdf({
            format: 'A4',
            margin: { top: '1.5cm', bottom: '1.5cm', left: '1.5cm', right: '1.5cm' },
            printBackground: true
        });

        await browser.close();

        // Save PDF to Storage
        const fileName = `${projectId}/v${versionNumber}_doc_${Date.now()}.pdf`;
        const { error: uErr } = await supabase.storage
            .from('documentation')
            .upload(fileName, pdfBuffer, { contentType: 'application/pdf', upsert: true });

        if (uErr) {
            // Bucket might not exist, skip and log
            console.warn('[AutoDocs] Storage upload warning (check bucket "documentation"):', uErr.message);
            return;
        }

        const { data: { publicUrl } } = supabase.storage.from('documentation').getPublicUrl(fileName);

        // Update DB with PDF URL
        await supabase.from('documentation_outputs')
            .update({ pdf_url: publicUrl })
            .eq('project_id', projectId)
            .eq('version', versionNumber);

        console.log(`[AutoDocs] PDF generated and linked: ${publicUrl}`);

    } catch (err: any) {
        console.error('[AutoDocs] PDF Generation FATAL:', err.message);
    }
}
